// Custom AMD-like loader, does not support circular dependencies
const __MODULES__ = {
    cache: {},
    pending: {},
    hasCycle: false,
    checkCycles: () => {
        const visited = new Set();
        const recursionStack = new Set();
        // Recursive depth-first search to trace dependency cycles
        function trace(module) {
            var _a;
            if (recursionStack.has(module)) {
                return [module];
            }
            if (visited.has(module)) {
                return [];
            }
            visited.add(module);
            recursionStack.add(module);
            const deps = ((_a = __MODULES__.pending[module]) === null || _a === void 0 ? void 0 : _a.unmetDeps) || [];
            for (const dep of deps) {
                const cycle = trace(dep);
                if (cycle.length > 0) {
                    cycle.push(module);
                    return cycle;
                }
            }
            recursionStack.delete(module);
            return [];
        }
        for (const module of Object.keys(__MODULES__.pending)) {
            if (!visited.has(module)) {
                const cycle = trace(module);
                if (cycle.length > 0) {
                    __MODULES__.hasCycle = true;
                    const firstNode = cycle[0];
                    const lastIndex = cycle.lastIndexOf(firstNode);
                    const minimalCycle = cycle.slice(0, lastIndex + 1);
                    throw new Error("Circular dependency " + minimalCycle.reverse().join(" -> "));
                }
            }
        }
    },
    get: (name) => __MODULES__.cache[name],
    set: (name, value) => (__MODULES__.cache[name] = value),
    resolve: (name, from) => {
        if (/^\.\.?\//.test(name)) {
            const absolutePath = from.split("/").slice(0, -1);
            const relativeDep = name.split("/");
            while (relativeDep[0] === "..") {
                relativeDep.shift();
                absolutePath.pop();
            }
            while (relativeDep[0] === ".") {
                relativeDep.shift();
            }
            name = [...absolutePath, ...relativeDep].join("/");
        }
        else {
            name = name.replace(/^@?\//, __ROOT_PATH__ + "/js/");
        }
        return name;
    },
    refresh: () => {
        if (__MODULES__.hasCycle)
            return;
        for (const [key, { unmetDeps, load }] of Object.entries(__MODULES__.pending)) {
            if (unmetDeps.every((name) => name in __MODULES__.cache)) {
                delete __MODULES__.pending[key];
                load();
            }
        }
        __MODULES__.checkCycles();
    },
};
const define = (...args) => {
    let name, deps, factory;
    // Webpack AMD modules are named, TypeScript AMD modules are not
    if ("string" === typeof args[0]) {
        name = args[0];
        deps = args[1];
        factory = args[2];
    }
    else {
        name = document.currentScript.src
            .replace(document.location.origin, "")
            .replace(/\.js$/, "");
        deps = args[0];
        factory = args[1];
    }
    // TypeScript AMD modules pass in require and exports
    if ("require" === deps[0] && "exports" === deps[1]) {
        deps = deps.slice(2);
        const load = () => {
            const require = (dep) => __MODULES__.get(__MODULES__.resolve(dep, name));
            const exports = {};
            factory.call(this, require, exports, ...deps.map(require));
            __MODULES__.set(name, exports);
            __MODULES__.refresh();
        };
        const unmetDeps = [];
        for (const dep of deps) {
            const resolved = __MODULES__.resolve(dep, name);
            !(resolved in __MODULES__.cache) && unmetDeps.push(resolved);
        }
        for (const dep of unmetDeps) {
            if (!Object.values(__MODULES__.pending).some(({ unmetDeps }) => unmetDeps.includes(dep))) {
                __LOAD_SCRIPT__(dep, true);
            }
        }
        __MODULES__.pending[name] = { unmetDeps, load };
        __MODULES__.refresh();
    }
    else {
        // Webpack UMDs do not load dynamically, add these script tags in order
        __MODULES__.set(name, factory.call(this, ...deps.map(__MODULES__.get)));
    }
};
define.amd = true; // lol no it's not, but pretend we are AMD/RequireJS
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmaW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9kZWZpbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUVBQWlFO0FBQ2pFLE1BQU0sV0FBVyxHQVNiO0lBQ0YsS0FBSyxFQUFFLEVBQUU7SUFDVCxPQUFPLEVBQUUsRUFBRTtJQUNYLFFBQVEsRUFBRSxLQUFLO0lBQ2YsV0FBVyxFQUFFLEdBQUcsRUFBRTtRQUNoQixNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ2xDLE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7UUFFekMsMERBQTBEO1FBQzFELFNBQVMsS0FBSyxDQUFDLE1BQWM7O1lBQzNCLElBQUksY0FBYyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO2dCQUMvQixPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDbEIsQ0FBQztZQUNELElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO2dCQUN4QixPQUFPLEVBQUUsQ0FBQztZQUNaLENBQUM7WUFFRCxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3BCLGNBQWMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFM0IsTUFBTSxJQUFJLEdBQUcsQ0FBQSxNQUFBLFdBQVcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLDBDQUFFLFNBQVMsS0FBSSxFQUFFLENBQUM7WUFDMUQsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztnQkFDdkIsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QixJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7b0JBQ3JCLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBQ25CLE9BQU8sS0FBSyxDQUFDO2dCQUNm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Tix1RUFBdUU7UUFDdkUsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUUsQ0FBQztBQUNILENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsb0RBQW9EIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3VzdG9tIEFNRC1saWtlIGxvYWRlciwgZG9lcyBub3Qgc3VwcG9ydCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcclxuY29uc3QgX19NT0RVTEVTX186IHtcclxuICBjYWNoZTogeyBbbmFtZTogc3RyaW5nXTogYW55IH07XHJcbiAgcGVuZGluZzogeyBbbmFtZTogc3RyaW5nXTogeyB1bm1ldERlcHM6IHN0cmluZ1tdOyBsb2FkOiAoKSA9PiB2b2lkIH0gfTtcclxuICBoYXNDeWNsZTogYm9vbGVhbjtcclxuICBjaGVja0N5Y2xlczogKCkgPT4gdm9pZDtcclxuICBnZXQ6IChuYW1lOiBzdHJpbmcpID0+IGFueTtcclxuICBzZXQ6IChuYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IHZvaWQ7XHJcbiAgcmVzb2x2ZTogKGRlcDogc3RyaW5nLCBjdXJyZW50OiBzdHJpbmcpID0+IHN0cmluZztcclxuICByZWZyZXNoOiAoKSA9PiB2b2lkO1xyXG59ID0ge1xyXG4gIGNhY2hlOiB7fSxcclxuICBwZW5kaW5nOiB7fSxcclxuICBoYXNDeWNsZTogZmFsc2UsXHJcbiAgY2hlY2tDeWNsZXM6ICgpID0+IHtcclxuICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgIGNvbnN0IHJlY3Vyc2lvblN0YWNrID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblxyXG4gICAgLy8gUmVjdXJzaXZlIGRlcHRoLWZpcnN0IHNlYXJjaCB0byB0cmFjZSBkZXBlbmRlbmN5IGN5Y2xlc1xyXG4gICAgZnVuY3Rpb24gdHJhY2UobW9kdWxlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgICAgIGlmIChyZWN1cnNpb25TdGFjay5oYXMobW9kdWxlKSkge1xyXG4gICAgICAgIHJldHVybiBbbW9kdWxlXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmlzaXRlZC5oYXMobW9kdWxlKSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmlzaXRlZC5hZGQobW9kdWxlKTtcclxuICAgICAgcmVjdXJzaW9uU3RhY2suYWRkKG1vZHVsZSk7XHJcblxyXG4gICAgICBjb25zdCBkZXBzID0gX19NT0RVTEVTX18ucGVuZGluZ1ttb2R1bGVdPy51bm1ldERlcHMgfHwgW107XHJcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcclxuICAgICAgICBjb25zdCBjeWNsZSA9IHRyYWNlKGRlcCk7XHJcbiAgICAgICAgaWYgKGN5Y2xlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGN5Y2xlLnB1c2gobW9kdWxlKTtcclxuICAgICAgICAgIHJldHVybiBjeWNsZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlY3Vyc2lvblN0YWNrLmRlbGV0ZShtb2R1bGUpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgT2JqZWN0LmtleXMoX19NT0RVTEVTX18ucGVuZGluZykpIHtcclxuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhtb2R1bGUpKSB7XHJcbiAgICAgICAgY29uc3QgY3ljbGUgPSB0cmFjZShtb2R1bGUpO1xyXG5cclxuICAgICAgICBpZiAoY3ljbGUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgX19NT0RVTEVTX18uaGFzQ3ljbGUgPSB0cnVlO1xyXG4gICAgICAgICAgY29uc3QgZmlyc3ROb2RlID0gY3ljbGVbMF07XHJcbiAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBjeWNsZS5sYXN0SW5kZXhPZihmaXJzdE5vZGUpO1xyXG4gICAgICAgICAgY29uc3QgbWluaW1hbEN5Y2xlID0gY3ljbGUuc2xpY2UoMCwgbGFzdEluZGV4ICsgMSk7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgIFwiQ2lyY3VsYXIgZGVwZW5kZW5jeSBcIiArIG1pbmltYWxDeWNsZS5yZXZlcnNlKCkuam9pbihcIiAtPiBcIiksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZ2V0OiAobmFtZTogc3RyaW5nKSA9PiBfX01PRFVMRVNfXy5jYWNoZVtuYW1lXSxcclxuICBzZXQ6IChuYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IChfX01PRFVMRVNfXy5jYWNoZVtuYW1lXSA9IHZhbHVlKSxcclxuICByZXNvbHZlOiAobmFtZTogc3RyaW5nLCBmcm9tOiBzdHJpbmcpID0+IHtcclxuICAgIGlmICgvXlxcLlxcLj9cXC8vLnRlc3QobmFtZSkpIHtcclxuICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gZnJvbS5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpO1xyXG4gICAgICBjb25zdCByZWxhdGl2ZURlcCA9IG5hbWUuc3BsaXQoXCIvXCIpO1xyXG4gICAgICB3aGlsZSAocmVsYXRpdmVEZXBbMF0gPT09IFwiLi5cIikge1xyXG4gICAgICAgIHJlbGF0aXZlRGVwLnNoaWZ0KCk7XHJcbiAgICAgICAgYWJzb2x1dGVQYXRoLnBvcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChyZWxhdGl2ZURlcFswXSA9PT0gXCIuXCIpIHtcclxuICAgICAgICByZWxhdGl2ZURlcC5zaGlmdCgpO1xyXG4gICAgICB9XHJcbiAgICAgIG5hbWUgPSBbLi4uYWJzb2x1dGVQYXRoLCAuLi5yZWxhdGl2ZURlcF0uam9pbihcIi9cIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9eQD9cXC8vLCBfX1JPT1RfUEFUSF9fICsgXCIvanMvXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWU7XHJcbiAgfSxcclxuICByZWZyZXNoOiAoKSA9PiB7XHJcbiAgICBpZiAoX19NT0RVTEVTX18uaGFzQ3ljbGUpIHJldHVybjtcclxuICAgIGZvciAoY29uc3QgW2tleSwgeyB1bm1ldERlcHMsIGxvYWQgfV0gb2YgT2JqZWN0LmVudHJpZXMoXHJcbiAgICAgIF9fTU9EVUxFU19fLnBlbmRpbmcsXHJcbiAgICApKSB7XHJcbiAgICAgIGlmICh1bm1ldERlcHMuZXZlcnkoKG5hbWUpID0+IG5hbWUgaW4gX19NT0RVTEVTX18uY2FjaGUpKSB7XHJcbiAgICAgICAgZGVsZXRlIF9fTU9EVUxFU19fLnBlbmRpbmdba2V5XTtcclxuICAgICAgICBsb2FkKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9fTU9EVUxFU19fLmNoZWNrQ3ljbGVzKCk7XHJcbiAgfSxcclxufTtcclxuXHJcbmNvbnN0IGRlZmluZSA9ICguLi5hcmdzOiBhbnkpID0+IHtcclxuICBsZXQgbmFtZTogc3RyaW5nLCBkZXBzOiBBcnJheTxzdHJpbmc+LCBmYWN0b3J5OiBGdW5jdGlvbjtcclxuXHJcbiAgLy8gV2VicGFjayBBTUQgbW9kdWxlcyBhcmUgbmFtZWQsIFR5cGVTY3JpcHQgQU1EIG1vZHVsZXMgYXJlIG5vdFxyXG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgYXJnc1swXSkge1xyXG4gICAgbmFtZSA9IGFyZ3NbMF07XHJcbiAgICBkZXBzID0gYXJnc1sxXTtcclxuICAgIGZhY3RvcnkgPSBhcmdzWzJdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBuYW1lID0gKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpLnNyY1xyXG4gICAgICAucmVwbGFjZShkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4sIFwiXCIpXHJcbiAgICAgIC5yZXBsYWNlKC9cXC5qcyQvLCBcIlwiKTtcclxuICAgIGRlcHMgPSBhcmdzWzBdO1xyXG4gICAgZmFjdG9yeSA9IGFyZ3NbMV07XHJcbiAgfVxyXG5cclxuICAvLyBUeXBlU2NyaXB0IEFNRCBtb2R1bGVzIHBhc3MgaW4gcmVxdWlyZSBhbmQgZXhwb3J0c1xyXG4gIGlmIChcInJlcXVpcmVcIiA9PT0gZGVwc1swXSAmJiBcImV4cG9ydHNcIiA9PT0gZGVwc1sxXSkge1xyXG4gICAgZGVwcyA9IGRlcHMuc2xpY2UoMik7XHJcblxyXG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcclxuICAgICAgY29uc3QgcmVxdWlyZSA9IChkZXA6IHN0cmluZykgPT5cclxuICAgICAgICBfX01PRFVMRVNfXy5nZXQoX19NT0RVTEVTX18ucmVzb2x2ZShkZXAsIG5hbWUpKTtcclxuICAgICAgY29uc3QgZXhwb3J0cyA9IHt9O1xyXG4gICAgICBmYWN0b3J5LmNhbGwodGhpcywgcmVxdWlyZSwgZXhwb3J0cywgLi4uZGVwcy5tYXAocmVxdWlyZSkpO1xyXG4gICAgICBfX01PRFVMRVNfXy5zZXQobmFtZSwgZXhwb3J0cyk7XHJcbiAgICAgIF9fTU9EVUxFU19fLnJlZnJlc2goKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdW5tZXREZXBzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XHJcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gX19NT0RVTEVTX18ucmVzb2x2ZShkZXAsIG5hbWUpO1xyXG4gICAgICAhKHJlc29sdmVkIGluIF9fTU9EVUxFU19fLmNhY2hlKSAmJiB1bm1ldERlcHMucHVzaChyZXNvbHZlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBkZXAgb2YgdW5tZXREZXBzKSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICAhT2JqZWN0LnZhbHVlcyhfX01PRFVMRVNfXy5wZW5kaW5nKS5zb21lKCh7IHVubWV0RGVwcyB9KSA9PlxyXG4gICAgICAgICAgdW5tZXREZXBzLmluY2x1ZGVzKGRlcCksXHJcbiAgICAgICAgKVxyXG4gICAgICApIHtcclxuICAgICAgICBfX0xPQURfU0NSSVBUX18oZGVwLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9fTU9EVUxFU19fLnBlbmRpbmdbbmFtZV0gPSB7IHVubWV0RGVwcywgbG9hZCB9O1xyXG4gICAgX19NT0RVTEVTX18ucmVmcmVzaCgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBXZWJwYWNrIFVNRHMgZG8gbm90IGxvYWQgZHluYW1pY2FsbHksIGFkZCB0aGVzZSBzY3JpcHQgdGFncyBpbiBvcmRlclxyXG4gICAgX19NT0RVTEVTX18uc2V0KG5hbWUsIGZhY3RvcnkuY2FsbCh0aGlzLCAuLi5kZXBzLm1hcChfX01PRFVMRVNfXy5nZXQpKSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZGVmaW5lLmFtZCA9IHRydWU7IC8vIGxvbCBubyBpdCdzIG5vdCwgYnV0IHByZXRlbmQgd2UgYXJlIEFNRC9SZXF1aXJlSlNcclxuIl19