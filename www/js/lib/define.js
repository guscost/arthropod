// Custom AMD-like loader, does not support circular dependencies
const __MODULES__ = {
    cache: {},
    pending: {},
    hasCycle: false,
    get: (name) => __MODULES__.cache[name],
    set: (name, value) => (__MODULES__.cache[name] = value),
    // Convert a module path to be relative to the output "js" directory
    resolve: (name, from) => {
        if (/^\.\.?\//.test(name)) {
            const absolutePath = from.split("/").slice(0, -1);
            const relativeDep = name.split("/");
            while (relativeDep[0] === "..") {
                relativeDep.shift();
                absolutePath.pop();
            }
            while (relativeDep[0] === ".") {
                relativeDep.shift();
            }
            name = [...absolutePath, ...relativeDep].join("/");
        }
        else {
            name = name.replace(/^@?\//, __ROOT_PATH__ + "/js/");
        }
        return name;
    },
    // Perform load of any modules that are ready
    refresh: () => {
        if (__MODULES__.hasCycle)
            return;
        for (const [key, { unmetDeps, load }] of Object.entries(__MODULES__.pending)) {
            if (unmetDeps.every((name) => name in __MODULES__.cache)) {
                delete __MODULES__.pending[key];
                load();
            }
        }
        __MODULES__.checkCycles();
    },
    // Recursive depth-first search to trace dependency cycles
    checkCycles: () => {
        const visited = new Set();
        const recursionStack = new Set();
        function trace(module) {
            var _a;
            if (recursionStack.has(module)) {
                return [module];
            }
            if (visited.has(module)) {
                return [];
            }
            visited.add(module);
            recursionStack.add(module);
            const deps = ((_a = __MODULES__.pending[module]) === null || _a === void 0 ? void 0 : _a.unmetDeps) || [];
            for (const dep of deps) {
                const cycle = trace(dep);
                if (cycle.length > 0) {
                    cycle.push(module);
                    return cycle;
                }
            }
            recursionStack.delete(module);
            return [];
        }
        // Trace all still-pending modules to see if we have a cycle
        for (const module of Object.keys(__MODULES__.pending)) {
            if (!visited.has(module)) {
                const cycle = trace(module);
                if (cycle.length > 0) {
                    __MODULES__.hasCycle = true;
                    const firstNode = cycle[0];
                    const lastIndex = cycle.lastIndexOf(firstNode);
                    const minimalCycle = cycle.slice(0, lastIndex + 1);
                    throw new Error("Circular dependency " + minimalCycle.reverse().join(" -> "));
                }
            }
        }
    },
};
// Main define function to load a module w/ dependencies into the __MODULES__ global object
const define = (...args) => {
    let name, deps, factory;
    // Webpack AMD modules are named
    if ("string" === typeof args[0]) {
        name = args[0];
        deps = args[1];
        factory = args[2];
        // Webpack modules do not load dynamically, add these script tags in order
        __MODULES__.set(name, factory.call(this, ...deps.map(__MODULES__.get)));
        // TypeScript AMD modules are not named
    }
    else {
        name = document.currentScript.src
            .replace(document.location.origin, "")
            .replace(/\.js$/, "");
        deps = args[0];
        factory = args[1];
        // TypeScript AMD modules pass in require and exports
        deps = deps.slice(2);
        // Load the module with all dependencies, when ready
        const load = () => {
            const require = (dep) => __MODULES__.get(__MODULES__.resolve(dep, name));
            const exports = {};
            factory.call(this, require, exports, ...deps.map(require));
            __MODULES__.set(name, exports);
            __MODULES__.refresh();
        };
        // Check which dependencies are not yet loaded
        const unmetDeps = [];
        for (const dep of deps) {
            const resolved = __MODULES__.resolve(dep, name);
            !(resolved in __MODULES__.cache) && unmetDeps.push(resolved);
        }
        // Dynamically add new AMD module dependencies in script elements
        for (const dep of unmetDeps) {
            if (!Object.values(__MODULES__.pending).some(({ unmetDeps }) => unmetDeps.includes(dep))) {
                __LOAD_SCRIPT__(dep, true);
            }
        }
        // Add this module to pending list and try to load
        __MODULES__.pending[name] = { unmetDeps, load };
        __MODULES__.refresh();
    }
};
define.amd = true; // lol no it's not, but pretend we are AMD/RequireJS
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmaW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9kZWZpbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUVBQWlFO0FBQ2pFLE1BQU0sV0FBVyxHQVNiO0lBQ0YsS0FBSyxFQUFFLEVBQUU7SUFDVCxPQUFPLEVBQUUsRUFBRTtJQUNYLFFBQVEsRUFBRSxLQUFLO0lBQ2YsR0FBRyxFQUFFLENBQUMsSUFBWSxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztJQUM5QyxHQUFHLEVBQUUsQ0FBQyxJQUFZLEVBQUUsS0FBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBRXBFLG9FQUFvRTtJQUNwRSxPQUFPLEVBQUUsQ0FBQyxJQUFZLEVBQUUsSUFBWSxFQUFFLEVBQUU7UUFDdEMsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDMUIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNwQyxPQUFPLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQztnQkFDL0IsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUNwQixZQUFZLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDckIsQ0FBQztZQUNELE9BQU8sV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO2dCQUM5QixXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDdEIsQ0FBQztZQUNELElBQUksR0FBRyxDQUFDLEdBQUcsWUFBWSxFQUFFLEdBQUcsV0FB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O1lBQzdCLENBQUM7UUFDSCxDQUFDO1FBRUQsa0RBQWtEO1FBQ2xELFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUM7UUFDaEQsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3hCLENBQUM7QUFDSCxDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLG9EQUFvRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIEN1c3RvbSBBTUQtbGlrZSBsb2FkZXIsIGRvZXMgbm90IHN1cHBvcnQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5jb25zdCBfX01PRFVMRVNfXzoge1xuICBjYWNoZTogeyBbbmFtZTogc3RyaW5nXTogYW55IH07XG4gIHBlbmRpbmc6IHsgW25hbWU6IHN0cmluZ106IHsgdW5tZXREZXBzOiBzdHJpbmdbXTsgbG9hZDogKCkgPT4gdm9pZCB9IH07XG4gIGhhc0N5Y2xlOiBib29sZWFuO1xuICBnZXQ6IChuYW1lOiBzdHJpbmcpID0+IGFueTtcbiAgc2V0OiAobmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB2b2lkO1xuICByZXNvbHZlOiAoZGVwOiBzdHJpbmcsIGN1cnJlbnQ6IHN0cmluZykgPT4gc3RyaW5nO1xuICByZWZyZXNoOiAoKSA9PiB2b2lkO1xuICBjaGVja0N5Y2xlczogKCkgPT4gdm9pZDtcbn0gPSB7XG4gIGNhY2hlOiB7fSxcbiAgcGVuZGluZzoge30sXG4gIGhhc0N5Y2xlOiBmYWxzZSxcbiAgZ2V0OiAobmFtZTogc3RyaW5nKSA9PiBfX01PRFVMRVNfXy5jYWNoZVtuYW1lXSxcbiAgc2V0OiAobmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiAoX19NT0RVTEVTX18uY2FjaGVbbmFtZV0gPSB2YWx1ZSksXG5cbiAgLy8gQ29udmVydCBhIG1vZHVsZSBwYXRoIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBvdXRwdXQgXCJqc1wiIGRpcmVjdG9yeVxuICByZXNvbHZlOiAobmFtZTogc3RyaW5nLCBmcm9tOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoL15cXC5cXC4/XFwvLy50ZXN0KG5hbWUpKSB7XG4gICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBmcm9tLnNwbGl0KFwiL1wiKS5zbGljZSgwLCAtMSk7XG4gICAgICBjb25zdCByZWxhdGl2ZURlcCA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgd2hpbGUgKHJlbGF0aXZlRGVwWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgcmVsYXRpdmVEZXAuc2hpZnQoKTtcbiAgICAgICAgYWJzb2x1dGVQYXRoLnBvcCgpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHJlbGF0aXZlRGVwWzBdID09PSBcIi5cIikge1xuICAgICAgICByZWxhdGl2ZURlcC5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgbmFtZSA9IFsuLi5hYnNvbHV0ZVBhdGgsIC4uLnJlbGF0aXZlRGVwXS5qb2luKFwiL1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXkA/XFwvLywgX19ST09UX1BBVEhfXyArIFwiL2pzL1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG4gIH0sXG5cbiAgLy8gUGVyZm9ybSBsb2FkIG9mIGFueSBtb2R1bGVzIHRoYXQgYXJlIHJlYWR5XG4gIHJlZnJlc2g6ICgpID0+IHtcbiAgICBpZiAoX19NT0RVTEVTX18uaGFzQ3ljbGUpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHsgdW5tZXREZXBzLCBsb2FkIH1dIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgX19NT0RVTEVTX18ucGVuZGluZyxcbiAgICApKSB7XG4gICAgICBpZiAodW5tZXREZXBzLmV2ZXJ5KChuYW1lKSA9PiBuYW1lIGluIF9fTU9EVUxFU19fLmNhY2hlKSkge1xuICAgICAgICBkZWxldGUgX19NT0RVTEVTX18ucGVuZGluZ1trZXldO1xuICAgICAgICBsb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fTU9EVUxFU19fLmNoZWNrQ3ljbGVzKCk7XG4gIH0sXG5cbiAgLy8gUmVjdXJzaXZlIGRlcHRoLWZpcnN0IHNlYXJjaCB0byB0cmFjZSBkZXBlbmRlbmN5IGN5Y2xlc1xuICBjaGVja0N5Y2xlczogKCkgPT4ge1xuICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCByZWN1cnNpb25TdGFjayA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZnVuY3Rpb24gdHJhY2UobW9kdWxlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgICBpZiAocmVjdXJzaW9uU3RhY2suaGFzKG1vZHVsZSkpIHtcbiAgICAgICAgcmV0dXJuIFttb2R1bGVdO1xuICAgICAgfVxuICAgICAgaWYgKHZpc2l0ZWQuaGFzKG1vZHVsZSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2aXNpdGVkLmFkZChtb2R1bGUpO1xuICAgICAgcmVjdXJzaW9uU3RhY2suYWRkKG1vZHVsZSk7XG5cbiAgICAgIGNvbnN0IGRlcHMgPSBfX01PRFVMRVNfXy5wZW5kaW5nW21vZHVsZV0/LnVubWV0RGVwcyB8fCBbXTtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcbiAgICAgICAgY29uc3QgY3ljbGUgPSB0cmFjZShkZXApO1xuICAgICAgICBpZiAoY3ljbGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN5Y2xlLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICByZXR1cm4gY3ljbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVjdXJzaW9uU3RhY2suZGVsZXRlKG1vZHVsZSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gVHJhY2UgYWxsIHN0aWxsLXBlbmRpbmcgbW9kdWxlcyB0byBzZWUgaWYgd2UgaGF2ZSBhIGN5Y2xlXG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgT2JqZWN0LmtleXMoX19NT0RVTEVTX18ucGVuZGluZykpIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMobW9kdWxlKSkge1xuICAgICAgICBjb25zdCBjeWNsZSA9IHRyYWNlKG1vZHVsZSk7XG5cbiAgICAgICAgaWYgKGN5Y2xlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBfX01PRFVMRVNfXy5oYXNDeWNsZSA9IHRydWU7XG4gICAgICAgICAgY29uc3QgZmlyc3ROb2RlID0gY3ljbGVbMF07XG4gICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gY3ljbGUubGFzdEluZGV4T2YoZmlyc3ROb2RlKTtcbiAgICAgICAgICBjb25zdCBtaW5pbWFsQ3ljbGUgPSBjeWNsZS5zbGljZSgwLCBsYXN0SW5kZXggKyAxKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNpcmN1bGFyIGRlcGVuZGVuY3kgXCIgKyBtaW5pbWFsQ3ljbGUucmV2ZXJzZSgpLmpvaW4oXCIgLT4gXCIpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG59O1xuXG4vLyBNYWluIGRlZmluZSBmdW5jdGlvbiB0byBsb2FkIGEgbW9kdWxlIHcvIGRlcGVuZGVuY2llcyBpbnRvIHRoZSBfX01PRFVMRVNfXyBnbG9iYWwgb2JqZWN0XG5jb25zdCBkZWZpbmUgPSAoLi4uYXJnczogYW55KSA9PiB7XG4gIGxldCBuYW1lOiBzdHJpbmcsIGRlcHM6IEFycmF5PHN0cmluZz4sIGZhY3Rvcnk6IEZ1bmN0aW9uO1xuXG4gIC8vIFdlYnBhY2sgQU1EIG1vZHVsZXMgYXJlIG5hbWVkXG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgYXJnc1swXSkge1xuICAgIG5hbWUgPSBhcmdzWzBdO1xuICAgIGRlcHMgPSBhcmdzWzFdO1xuICAgIGZhY3RvcnkgPSBhcmdzWzJdO1xuXG4gICAgLy8gV2VicGFjayBtb2R1bGVzIGRvIG5vdCBsb2FkIGR5bmFtaWNhbGx5LCBhZGQgdGhlc2Ugc2NyaXB0IHRhZ3MgaW4gb3JkZXJcbiAgICBfX01PRFVMRVNfXy5zZXQobmFtZSwgZmFjdG9yeS5jYWxsKHRoaXMsIC4uLmRlcHMubWFwKF9fTU9EVUxFU19fLmdldCkpKTtcblxuICAgIC8vIFR5cGVTY3JpcHQgQU1EIG1vZHVsZXMgYXJlIG5vdCBuYW1lZFxuICB9IGVsc2Uge1xuICAgIG5hbWUgPSAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCkuc3JjXG4gICAgICAucmVwbGFjZShkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4sIFwiXCIpXG4gICAgICAucmVwbGFjZSgvXFwuanMkLywgXCJcIik7XG4gICAgZGVwcyA9IGFyZ3NbMF07XG4gICAgZmFjdG9yeSA9IGFyZ3NbMV07XG5cbiAgICAvLyBUeXBlU2NyaXB0IEFNRCBtb2R1bGVzIHBhc3MgaW4gcmVxdWlyZSBhbmQgZXhwb3J0c1xuICAgIGRlcHMgPSBkZXBzLnNsaWNlKDIpO1xuXG4gICAgLy8gTG9hZCB0aGUgbW9kdWxlIHdpdGggYWxsIGRlcGVuZGVuY2llcywgd2hlbiByZWFkeVxuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1aXJlID0gKGRlcDogc3RyaW5nKSA9PlxuICAgICAgICBfX01PRFVMRVNfXy5nZXQoX19NT0RVTEVTX18ucmVzb2x2ZShkZXAsIG5hbWUpKTtcbiAgICAgIGNvbnN0IGV4cG9ydHMgPSB7fTtcbiAgICAgIGZhY3RvcnkuY2FsbCh0aGlzLCByZXF1aXJlLCBleHBvcnRzLCAuLi5kZXBzLm1hcChyZXF1aXJlKSk7XG4gICAgICBfX01PRFVMRVNfXy5zZXQobmFtZSwgZXhwb3J0cyk7XG4gICAgICBfX01PRFVMRVNfXy5yZWZyZXNoKCk7XG4gICAgfTtcblxuICAgIC8vIENoZWNrIHdoaWNoIGRlcGVuZGVuY2llcyBhcmUgbm90IHlldCBsb2FkZWRcbiAgICBjb25zdCB1bm1ldERlcHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IF9fTU9EVUxFU19fLnJlc29sdmUoZGVwLCBuYW1lKTtcbiAgICAgICEocmVzb2x2ZWQgaW4gX19NT0RVTEVTX18uY2FjaGUpICYmIHVubWV0RGVwcy5wdXNoKHJlc29sdmVkKTtcbiAgICB9XG5cbiAgICAvLyBEeW5hbWljYWxseSBhZGQgbmV3IEFNRCBtb2R1bGUgZGVwZW5kZW5jaWVzIGluIHNjcmlwdCBlbGVtZW50c1xuICAgIGZvciAoY29uc3QgZGVwIG9mIHVubWV0RGVwcykge1xuICAgICAgaWYgKFxuICAgICAgICAhT2JqZWN0LnZhbHVlcyhfX01PRFVMRVNfXy5wZW5kaW5nKS5zb21lKCh7IHVubWV0RGVwcyB9KSA9PlxuICAgICAgICAgIHVubWV0RGVwcy5pbmNsdWRlcyhkZXApLFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgX19MT0FEX1NDUklQVF9fKGRlcCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoaXMgbW9kdWxlIHRvIHBlbmRpbmcgbGlzdCBhbmQgdHJ5IHRvIGxvYWRcbiAgICBfX01PRFVMRVNfXy5wZW5kaW5nW25hbWVdID0geyB1bm1ldERlcHMsIGxvYWQgfTtcbiAgICBfX01PRFVMRVNfXy5yZWZyZXNoKCk7XG4gIH1cbn07XG5cbmRlZmluZS5hbWQgPSB0cnVlOyAvLyBsb2wgbm8gaXQncyBub3QsIGJ1dCBwcmV0ZW5kIHdlIGFyZSBBTUQvUmVxdWlyZUpTXG4iXX0=